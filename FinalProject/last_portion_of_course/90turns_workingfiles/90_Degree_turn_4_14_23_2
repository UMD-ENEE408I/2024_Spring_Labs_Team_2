
// currently this measures both encoder counts as well as moves the motors and implements a PID, right now the enc2 for M2 is coutning way too high and spinning much faster then the M1 (left motor)

// M1 is left motor, facing forward, M2 is right motor
#include <Arduino.h>
#include <Encoder.h>
#include <Adafruit_MCP3008.h>


//encoder pins
const unsigned int M1_ENC_A = 39;
const unsigned int M1_ENC_B = 38;
const unsigned int M2_ENC_A = 37;
const unsigned int M2_ENC_B = 36;

long previous_time;
long previous_error; //should these two go into void loop?
float error_integral;
float error_derivative;
 
//motor pins
const unsigned int M1_IN_1 = 13; //pins that singals appear on
const unsigned int M1_IN_2 = 12;
const unsigned int M2_IN_1 = 25;
const unsigned int M2_IN_2 = 14;
const unsigned int M1_IN_1_CHANNEL = 8; //channels that generate the pwm signals
const unsigned int M1_IN_2_CHANNEL = 9;
const unsigned int M2_IN_1_CHANNEL = 10;
const unsigned int M2_IN_2_CHANNEL = 11;

const unsigned int PWM_VALUE = 512; // 512 Max PWM given 8 bit resolution

const int freq = 5000;
const int ledChannel = 0;
const int resolution = 10;

const float Kp = 8;
const float Kd = 1;
const float Ki = 5;
//define functions
//Motor 1
//Encoder enc1(M1_ENC_A, M1_ENC_B); //built in function in encoder.h library sets pins to be read
//Encoder enc2(M2_ENC_A, M2_ENC_B);

//motor pwm need to be set currently above 300pwm, speed input into lcd write has to be positive
void M2_set_speed(int speed) { //right motor facing forward
// Serial.print("M2speed");
//   Serial.print(speed);
//   Serial.println();
//   Serial.print("M2absspeed");
//   Serial.print(abs(speed));
//   Serial.println();
  if(speed<0) { //turn foward 
     if(abs(speed)>512){
      speed=-512;
     }
    // if(abs(speed)<350){
    //   speed = -350; //case where there is not enough torque to move motor
    // }
     speed = abs(speed);
    //  Serial.print("speed M2 from set speed function ");
    // Serial.print(speed);
    // Serial.println();
     ledcWrite(M2_IN_1_CHANNEL, 0);
     ledcWrite(M2_IN_2_CHANNEL, speed);
  }else if(speed>0){  //speed is positive
    if (abs(speed)>512){
      speed =512;
    }
    // if(abs(speed)<350){
    //   speed = 350; //case where there is not enough torque to move motor
    // }
    // Serial.print("speed M2 from set speed function ");
    // Serial.print(speed);
    // Serial.println();
    ledcWrite(M2_IN_1_CHANNEL, speed); //turn backward
    ledcWrite(M2_IN_2_CHANNEL, 0);
  }
  else { //shut off motor
   ledcWrite(M2_IN_1_CHANNEL, speed); //turn backward
   ledcWrite(M2_IN_2_CHANNEL,speed);
  }
  // Serial.print("M2speed");
  // Serial.print(speed);
  // Serial.println();

}

void M1_set_speed(int speed) { //left motor facing forward
// Serial.print("M1speed");
//   Serial.print(speed);
//   Serial.println();
//    Serial.print("M1absspeed");
//   Serial.print(abs(speed));
//   Serial.println();
  if(speed<0) { //turn backward left motor used for left turn
    if(abs(speed)>512){
       speed=-512;
    }
    // if(abs(speed)<350){
    //   speed = -350; //case where there is not enough torque to move motor
    // }
    speed = abs(speed);
    // Serial.print("speed M1 from set speed function ");
    // Serial.print(speed);
    // Serial.println();
    ledcWrite(M1_IN_1_CHANNEL, speed); //ledcwrite(channel, duty cycle)
    ledcWrite(M1_IN_2_CHANNEL, 0);
  
  }else if(speed>0){  //turn forward usef for right turn
    if(abs(speed)>512){
        speed=512;
    }  
    //  if(abs(speed)<350){
    //   speed = 350; //case where there is not enough torque to move motor
    // }
    // Serial.print("speed M1 from set speed function ");
    // Serial.print(speed);
    // Serial.println();
    ledcWrite(M1_IN_1_CHANNEL, 0);
    ledcWrite(M1_IN_2_CHANNEL, speed);
  }else { //shut off motor
   ledcWrite(M1_IN_1_CHANNEL, speed); //turn backward
   ledcWrite(M1_IN_2_CHANNEL, speed);
  }
  
}


//pass in encoder count for M1 and the desired turn count for M1 as well as parameters Kp,Ki,Kd,this returns the speed value to intput inot the motors
int PID_controller_turn_speed(int enc_value_M1, float Kp, float Kd,float Ki,int ending_encoder_count) {
 // referenrece is the desired_turn_count
  
  // int amount_to_finish_turn = amount_to_finish_turn;
  long current_time = micros(); //get current time
  float delta_t = (current_time - previous_time)/(1.0e6); //convert time to seconds
  float error = ending_encoder_count - enc_value_M1; // -200 - 0, -200 - -20 = -180ending encoder count = initialenc1valuel+90, currnetl reading this is 0 when there is an error of 200
  error_derivative = (error - previous_error)/delta_t;
  error_integral = error_integral + error*delta_t; // is it posible that the second term is 0 because of too small of a delta t
  //should be global
  int speed = Kp*error + Kd*error_derivative + Ki*error_integral;
 //ramp input for position encoder
  
  previous_error = error; //should be global
  previous_time = current_time; //should be global
  Serial.println();
  Serial.print("m1speed ");
  Serial.print(speed);
  Serial.println();
  Serial.print("error ");
  Serial.print(error);

   Serial.println();
  Serial.print("deltat ");
  Serial.print(delta_t);
  Serial.println();
  Serial.print("error_integral ");
  Serial.print(error_integral);
   Serial.println();
  Serial.print("error_derivative ");
  Serial.print(error_derivative);
  Serial.println();
  return speed;
}


//this function will turn the mouse 90 degrees to the left, motors are in opposite directions so their encoder count will be the same sign depending on the direction you wish to turn
void turn_left(int ending_encoder_count, int enc_value_M1,float Kp, float Kd, float Ki) {
  //should we be passing in encm1 into pid controller?
  int speedM1 = PID_controller_turn_speed(enc_value_M1, Kp, Kd, Ki,ending_encoder_count);
  // M1_backward_pid_control(speedM1); //left motor
  // M2_forward_pid_control(speedM1); //right motor
  // Serial.println();
  // Serial.print("setting speed");

  M1_set_speed(speedM1);
  M2_set_speed(speedM1);
  //  Serial.println();
  // Serial.print("speedM1 passed from PID controller into M1");
   
}

//turn left 

 void turn_left_90()
 {
  Encoder enc1(M1_ENC_A, M1_ENC_B); //built in function in encoder.h library sets pins to be read
  Encoder enc2(M2_ENC_A, M2_ENC_B);
  int set_90_count = -240; //positive value for turning both wheels one cw the other ccw,approximate count for turning 90 degrees to the left
  //Either Set encoder to zero or add desired to encodervalue to set desired
  int tempvalue =0;
  //ramp input for set_90_count 
  
  //starting encoder values
   long enc1_value = enc1.read();
   long enc2_value = enc2.read();
     Serial.print("starting encoder1 count ");
     Serial.print(enc1_value);
     Serial.println(); 
  while(tempvalue > set_90_count ){
      //int ending_encoder_count_M1 = enc1_value + set_90_count; //whatever encoder value its reading -200/90degrees ,if necoder reads -10, and set point is -200 amount to finish is -90we need it to go
       //add 10percent everytime, currenlty becoming more and more negative
      Serial.print("tempvalue "); 
      Serial.print(tempvalue);
      Serial.println(); 
      int ending_encoder_count_M1 = enc1_value + tempvalue; //-20, -40, -60, -80, -100.. -200 set90 count
      tempvalue = 0.1*set_90_count + tempvalue;
      Serial.print("ending encoder countM1 "); 
      Serial.print(ending_encoder_count_M1);
      Serial.println(); 
      bool cont = true;
    while(cont) {
      // int A[10000];
    
      //int amount_to_finish_turn = ending_encoder_count_M1 - enc1_value; //whatever the final encoder count is - current enc1 value
      // when enc1_Value reads negative then amount to finish turn increases ie -200 - (-100)=300
      //pass the amount to finish turn encoder count into the 90degreeturn left which will spit out a speed/pwm value from the pid loop and move M1 and M2 that pwm
 // if there is not enough torque to move the motors I am passing in the same enc1 and endingencoder count which means no change in error and therefore integral term and proportional and not working
      turn_left(ending_encoder_count_M1,enc1_value,Kp, Kd, Ki); //ending encoder count instead of enc1_value
      // delay is amount motors run for set speed
      delayMicroseconds(100);
      //exit clause turn completed
        if(0.95*ending_encoder_count_M1 > enc1_value > 0.97*ending_encoder_count_M1)  //ex: -69>enc1>-73 < -200, first 0 != -20, if ending_encoder value = -73, and enc = -71 it will not equal this and continue turning to enc = -80
        // *** its currently trying to reach that value exactly and will continue to go back and forth until its exact, this will not actually happen, like encoder go to quickely and program will miss the ncessar yvalue
       // ****either enter this clause if enc1value <= ending encoder count, this iwll be a problem for the final value where we want it to be exact, and overshoot occurs in the correct direction
        {
          Serial.print("exitclause");
          Serial.println(); 
          M1_set_speed(0);
          M2_set_speed(0);
          cont =false;
        }
        // M1_stop();
        // M2_stop();
        // delay(3000);
        enc1_value = enc1.read();
        enc2_value = enc2.read();
        Serial.print("enc1 ");
        Serial.print(enc1_value);
        Serial.println(); //-200 - -(50) = -150 amount to finish turn
    }
  }
 }


void setup() {

// Stop the right motor by setting pin 14 low
  // this pin floats high or is pulled
  // high during the bootloader phase for some reason
  pinMode(14, OUTPUT);
  digitalWrite(14, LOW);
  delay(100);
  Serial.begin(115200);
// set up motors

  // we can control the pwm of indepenent motors 
  // esp32 has 16 possible channels to generate independent waveforms // create pwm sources
  ledcSetup(M1_IN_1_CHANNEL, freq, resolution); //configure LED PWM functionalities
  ledcSetup(M1_IN_2_CHANNEL, freq, resolution);
  ledcSetup(M2_IN_1_CHANNEL, freq, resolution);
  ledcSetup(M2_IN_2_CHANNEL, freq, resolution);
 //attach the channel (pwm sources) to the GPIO to be controlled these are the output pins
  ledcAttachPin(M1_IN_1, M1_IN_1_CHANNEL); //ledcattachpin(GPIO,CHannel)
  ledcAttachPin(M1_IN_2, M1_IN_2_CHANNEL);
  ledcAttachPin(M2_IN_1, M2_IN_1_CHANNEL);
  ledcAttachPin(M2_IN_2, M2_IN_2_CHANNEL);

   
}

void loop() {
 
 delay (1000);
    turn_left_90();
  //  Serial.print("90degree turn is called");
     delay(4000);
    // int i = 0;
    // while(i<1500){
    //     M1_backward_pid_control(i);
    //     Serial.print("I-Count");
    //     Serial.print(i);
    //     Serial.println();
    //     delayMicroseconds(100000);//min value 250 with no load, max around 590
    //   i++;
    // }


  //  delay(100); 
   // i++;
 // }
// int speed; //speed>0 right turn, speed less<0 left turn, speed =0 stop
// speed = 0;
// M1_set_speed(0); //left motor will turn M1_forward 
// M2_set_speed(0);
// delay(3000);
// // //right turn
// // speed = 600;
// // Serial.print("speed");
// // Serial.print(speed);
// // Serial.println();
// M1_set_speed(600); //left motor will turn M1_forward 
// M2_set_speed(600); //right motor will turn M2_backward
// // //left turn
// delay(3000);
// // speed = 0;
// // Serial.print("speed");
// // Serial.print(speed);
// // Serial.println();
// M1_set_speed(0); //left motor will turn M1_forward 
// M2_set_speed(0);
//  delay(3000);
// // speed = -600;
// // Serial.print("speed");
// // Serial.print(speed);
// // Serial.println();
// M1_set_speed(-500); //left motor will turn M1_forward 
// M2_set_speed(-500);
//  delay(3000);
// // speed = 0;
// // Serial.print("speed");
// // Serial.print(speed);
// // Serial.println();
// // M1_set_speed(speed); //left motor will turn M1_forward 
// // M2_set_speed(speed);
// // delay(3000);

  exit(0);
}
//positibve moving toward sensor, negative moving away from sensor

