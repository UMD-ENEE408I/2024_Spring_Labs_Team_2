
// currently this measures both encoder counts as well as moves the motors and implements a PID, right now the enc2 for M2 is coutning way too high and spinning much faster then the M1 (left motor)

// M1 is left motor, facing forward, M2 is right motor
#include <Arduino.h>
#include <Encoder.h>
#include <Adafruit_MCP3008.h>


//encoder pins
const unsigned int M1_ENC_A = 39;
const unsigned int M1_ENC_B = 38;
const unsigned int M2_ENC_A = 37;
const unsigned int M2_ENC_B = 36;

int base_pid = 250;

long previous_time = 0;
long previous_error = 0; //should these two go into void loop?
 
//motor pins
const unsigned int M1_IN_1 = 13; //pins that singals appear on
const unsigned int M1_IN_2 = 12;
const unsigned int M2_IN_1 = 25;
const unsigned int M2_IN_2 = 14;
const unsigned int M1_IN_1_CHANNEL = 8; //channels that generate the pwm signals
const unsigned int M1_IN_2_CHANNEL = 9;
const unsigned int M2_IN_1_CHANNEL = 10;
const unsigned int M2_IN_2_CHANNEL = 11;

const unsigned int PWM_VALUE = 512; // 512 Max PWM given 8 bit resolution

const int freq = 5000;
const int ledChannel = 0;
const int resolution = 10;

const float Kp = 1;
const float Kd = 1;
const float Ki = 1;
//define functions
//Motor 1
//Encoder enc1(M1_ENC_A, M1_ENC_B); //built in function in encoder.h library sets pins to be read
//Encoder enc2(M2_ENC_A, M2_ENC_B);

void M1_backward() {
  ledcWrite(M1_IN_1_CHANNEL, PWM_VALUE); //ledcwrite(channel, duty cycle)
  ledcWrite(M1_IN_2_CHANNEL, 0);
}

void M1_backward_pid_control(int pid_value) {
  if(pid_value > 512){ //should this be magnitude
    pid_value = 512;
  }
  ledcWrite(M1_IN_1_CHANNEL, pid_value); //ledcwrite(channel, duty cycle)
  ledcWrite(M1_IN_2_CHANNEL, 0);
}

void M1_forward() {
  ledcWrite(M1_IN_1_CHANNEL, 0);
  ledcWrite(M1_IN_2_CHANNEL, PWM_VALUE);
}
void M1_forward_pid_control(int pid_value) {
  if(pid_value > 512){
    pid_value = 512;
  }
  ledcWrite(M1_IN_1_CHANNEL, 0);
  ledcWrite(M1_IN_2_CHANNEL, pid_value);
}

void M1_stop() {
  ledcWrite(M1_IN_1_CHANNEL, PWM_VALUE);
  ledcWrite(M1_IN_2_CHANNEL, PWM_VALUE);
}

//motor 2
void M2_backward() {
  ledcWrite(M2_IN_1_CHANNEL, PWM_VALUE);
  ledcWrite(M2_IN_2_CHANNEL, 0);
}

void M2_backward_pid_control(int pid_value) {
  if(pid_value > 512){
    pid_value = 512;
  }
  ledcWrite(M2_IN_1_CHANNEL, pid_value);
  ledcWrite(M2_IN_2_CHANNEL, 0);
}

void M2_forward () {
  ledcWrite(M2_IN_1_CHANNEL, 0);
  ledcWrite(M2_IN_2_CHANNEL, PWM_VALUE);
}

void M2_forward_pid_control(int pid_value) {
  if(pid_value > 512){
    pid_value = 512;
  }
  ledcWrite(M2_IN_1_CHANNEL, 0);
  ledcWrite(M2_IN_2_CHANNEL, pid_value);
}

void M2_stop() { //change value of led // select duty cycle for the pin
  ledcWrite(M2_IN_1_CHANNEL, PWM_VALUE);
  ledcWrite(M2_IN_2_CHANNEL, PWM_VALUE);
}


//this function returns the speed of M2 based on the encoder count of M1, the returned speed is the speed to be inputted into the move forward function,
// the pid controller is for 1 motor to match the count of the second motor, there will always be a slight lag
int PID_controller(int encM1_count, int encM2_count, float Kp, float Kd,float Ki) {
  
  long current_time = micros(); //get current time
  float delta_t = (current_time - previous_time)/(1.0e6); //convert time to seconds
  float error = encM1_count - encM2_count;
  float error_derivative = (error - previous_error)/delta_t;
  float error_integral = error_integral + error*delta_t;

  int speedM2 = Kp*error + Kd*error_derivative + Ki*error_integral;

  previous_error = error;
  previous_time = current_time;

  return speedM2;
}

//pass in encoder count for M1 and the desired turn count for M1 as well as parameters Kp,Ki,Kd,this returns the speed value to intput inot the motors
int PID_controller_turn_speed(int enc_value_M1, float Kp, float Kd,float Ki,int amount_to_finish_turn) {
 // referenrece is the desired_turn_count
  
  // int amount_to_finish_turn = amount_to_finish_turn;
  long current_time = micros(); //get current time
  float delta_t = (current_time - previous_time)/(1.0e6); //convert time to seconds
  float error = enc_value_M1 - amount_to_finish_turn; //ending encoder count = initialenc1valuel+90, currnetl reading this is 0 when there is an error of 200
  float error_derivative = (error - previous_error)/delta_t;
  float error_integral = error_integral + error*delta_t;
  int speed = Kp*error + Kd*error_derivative + Ki*error_integral;

  previous_error = error;
  previous_time = current_time;
  //if speed > 512 set speed to 512
  return speed;
}


//this function will turn the mouse 90 degrees to the left, motors are in opposite directions so their encoder count will be the same sign depending on the direction you wish to turn
void turn_left(int amount_to_finish_turn, int enc_value_M1,float Kp, float Kd, float Ki) {
  //should we be passing in encm1 into pid controller?
  int speedM1 = PID_controller_turn_speed(enc_value_M1, Kp, Kd, Ki,amount_to_finish_turn);
  M1_backward_pid_control(speedM1); //left motor
  M2_forward_pid_control(speedM1); //right motor
   
}

//turn left 

 void turn_left_90()
 {
  Encoder enc1(M1_ENC_A, M1_ENC_B); //built in function in encoder.h library sets pins to be read
  Encoder enc2(M2_ENC_A, M2_ENC_B);
  int set_90_count = -200; //positive value for turning both wheels one cw the other ccw,approximate count for turning 90 degrees to the left
  //Either Set encoder to zero or add desired to encodervalue to set desired
  bool cont = true;
  //starting encoder values
   long enc1_value = enc1.read();
   long enc2_value = enc2.read();
     Serial.print("starting encoder1 count ");
     Serial.print(enc1_value);
     Serial.println(); 
    int ending_encoder_count_M1 = enc1_value + set_90_count; //whatever encoder value its reading -200/90degrees ,if necoder reads -10, and set point is -200 amount to finish is -90we need it to go
    Serial.print("ending encoder countM1 "); 
     Serial.print(ending_encoder_count_M1);
     Serial.println(); 
  while(cont) {
    enc1_value = enc1.read();
    enc2_value = enc2.read();
    Serial.print("enc1 ");
     Serial.print(enc1_value);
     Serial.println(); //-200 - -(50) = -150 amount to finish turn
    int amount_to_finish_turn = ending_encoder_count_M1 - enc1_value; //whatever the final encoder count is - current enc1 value
    // when enc1_Value reads negative then amount to finish turn increases ie 200 - (-100)=300
    //pass the amount to finish turn encoder count into the 90degreeturn left which will spit out a speed/pwm value from the pid loop and move M1 and M2 that pwm
     Serial.print("ammount_to_finish_turn");
     Serial.print(amount_to_finish_turn);
     Serial.println(); 
    turn_left(amount_to_finish_turn,enc1_value,Kp, Kd, Ki); //ending encoder count instead of enc1_value
    // delay is amount motors run for set speed
    delay(50);
    //exit clause turn completed
      if(enc1_value<=ending_encoder_count_M1)  //enc1 < -200
      {
        Serial.print("exitclause");
        M1_stop();
        M2_stop();
        cont =false;
      }
      M1_stop();
      M2_stop();
      delay(3000);
  }
  
 }

//this function will turn the mouse 90 degrees to the left 
void turn_90degree_right(int encM2_count, int encM1_count,float Kp, float Kd, float Ki) {
  int desired_turn_count = -200; //negative value for turning both wheels one cw the other ccw, approximate count for turning 90 degrees

 int speedM1 = PID_controller_turn_speed(encM1_count, Kp, Kd, Ki,desired_turn_count);
 int speedM2=  PID_controller_turn_speed(encM2_count, Kp, Kd, Ki, desired_turn_count);

 M1_forward_pid_control(speedM1);
 M2_forward_pid_control(speedM2);

  
}




void setup() {

// Stop the right motor by setting pin 14 low
  // this pin floats high or is pulled
  // high during the bootloader phase for some reason
  pinMode(14, OUTPUT);
  digitalWrite(14, LOW);
  delay(100);
  Serial.begin(115200);
// set up motors

  // we can control the pwm of indepenent motors 
  // esp32 has 16 possible channels to generate independent waveforms // create pwm sources
  ledcSetup(M1_IN_1_CHANNEL, freq, resolution); //configure LED PWM functionalities
  ledcSetup(M1_IN_2_CHANNEL, freq, resolution);
  ledcSetup(M2_IN_1_CHANNEL, freq, resolution);
  ledcSetup(M2_IN_2_CHANNEL, freq, resolution);
 //attach the channel (pwm sources) to the GPIO to be controlled these are the output pins
  ledcAttachPin(M1_IN_1, M1_IN_1_CHANNEL); //ledcattachpin(GPIO,CHannel)
  ledcAttachPin(M1_IN_2, M1_IN_2_CHANNEL);
  ledcAttachPin(M2_IN_1, M2_IN_1_CHANNEL);
  ledcAttachPin(M2_IN_2, M2_IN_2_CHANNEL);

   
}

void loop() {
 
  // long enc1_value = 0; // initilize to 0
  // long enc2_value = 0;
  
  //M2_stop();
  // Create the encoder objects after the motor has
  // stopped, else some sort exception is triggered
  // Encoder enc1(M1_ENC_A, M1_ENC_B); //built in function in encoder.h library sets pins to be read
  // Encoder enc2(M2_ENC_A, M2_ENC_B); //begin counts

 // M1_forward_pid_control(base_pid); //start at initial speed
 // M2_forward_pid_control(base_pid); //start at intitial speed
 // Serial.print("both motors forward by base pid ");
  
    
    // turn_90degree_left(enc1_value,enc2_value,Kp, Kd, Ki);
    // delay(50);
    // M1_stop();
    // M2_stop();
    // delay(3000);
    //if my encoder count matches desired count stop loop, if it overshoots desired count then turn right

   // turn_90degree_right(enc1_value,enc2_value,Kp, Kd, Ki);
 
   turn_left_90();
   Serial.print("90degree turn is called");
    
  //  delay(100); 
   // i++;
 // }



  
  
  exit(0);
}
//positibve moving toward sensor, negative moving away from sensor

